diff a/drivers/video/fbdev/msm/mdss_dsi_panel.c b/drivers/video/fbdev/msm/mdss_dsi_panel.c	(rejected hunks)
@@ -34,6 +47,81 @@
 
 DEFINE_LED_TRIGGER(bl_led_trigger);
 
+//SW4-HL-Display-BBox-03*{_20161028
+//SW4-HL-Display-BBox-02*{_20161021
+//SW4-HL-Display-BBox-01*{_20160804
+//SW4-HL-Display-BBox-00+{_20150610
+/* Black Box */
+#define BBOX_LCM_GPIO_FAIL 		do {printk("BBox;%s: LCM GPIO fail\n", __func__); printk("BBox::UEC;0::1\n");} while (0);
+#define BBOX_LCM_DISPLA_ON_FAIL	do {printk("BBox;%s: LCM Display on fail\n", __func__); printk("BBox::UEC;0::2\n");} while (0);
+#define BBOX_LCM_DISPLA_OFF_FAIL	do {printk("BBox;%s: LCM Display off fail\n", __func__); printk("BBox::UEC;0::3\n");} while (0);
+#define BBOX_LCM_DRIVER_IC_POWER_STATUS_NOT_08_FAIL	do {printk("BBox;%s: LCM driver ic power status is not 0x08\n", __func__); printk("BBox::UEC;0::5\n");} while (0);
+#define BBOX_LCM_DRIVER_IC_POWER_STATUS_NOT_0A_FAIL	do {printk("BBox;%s: LCM driver ic power status is not 0x0A\n", __func__); printk("BBox::UEC;0::6\n");} while (0);
+#define BBOX_LCM_OEM_FUNCTIONS_FAIL	do {printk("BBox;%s: LCM OEM functions (CE or CT or BLF or CABC) functions fail!\n", __func__); printk("BBox::UEC;0::8\n");} while (0);
+//SW4-HL-Display-BBox-00+}_20150610
+//SW4-HL-Display-BBox-01*}_20160804
+//SW4-HL-Display-BBox-02*}_20161021
+//SW4-HL-Display-BBox-03*}_20161028
+
+#define PANEL_REG_ADDR_LEN 8					//SW4-HL-Display-DynamicReadWriteRegister-00+_20160729
+
+//SW4-HL-TP-EnableDisableIrqRightAfterOrBeforeLcmDisplayOnOrdisplayOff-00+{_20170515
+extern void fih_tp_lcm_resume(void);
+extern int fih_tp_lcm_resume_lpwg_off(void);		//SW4-HL-Touch-ImplementDoubleTap-00+_20170623
+extern void fih_tp_lcm_resume_sensing_start(void);	//SW4-HL-Touch-ImplementDoubleTap-00+_20170623
+extern void fih_tp_lcm_suspend(void);
+//SW4-HL-TP-EnableDisableIrqRightAfterOrBeforeLcmDisplayOnOrdisplayOff-00+}_20170515
+
+//TBD - extern Touch suspend/resume function here
+//extern void fts_tp_lcm_suspend(void);
+
+//SW4-HL-TP-BringUpGT915L-00+{_20180119
+extern void fih_goodix_ts_resume(void);
+extern void fih_goodix_ts_suspend(void);
+//SW4-HL-TP-BringUpGT915L-00+}_20180119
+
+//SW4-HL-TP-B2N-NT36672-DoubleTap-00+{_20180302
+extern void fih_nvt_ts_resume(void);
+extern void fih_nvt_ts_suspend(void);
+extern int gdouble_tap_enable_nvt;
+//SW4-HL-TP-B2N-NT36672-DoubleTap-00+}_20180302
+
+//SW4-HL-Display-ImplementCECTCABC-00+{_20160126
+static int ce_status = 0;
+static int ct_status = 0;
+static int cabc_status = 0;
+
+extern int SendCEOnlyAfterResume;
+extern unsigned long ce_en;
+extern int SendCTOnlyAfterResume;
+extern unsigned long ct_set;
+extern int SendCABCOnlyAfterResume;
+extern unsigned long cabc_set;
+
+extern int gdouble_tap_enable;	//SW4-HL-Touch-ImplementDoubleTap-00+_20170623
+
+// Start
+static int aie_status = 0;
+
+extern int SendAIEOnlyAfterResume;
+extern unsigned long aie_set;
+// End
+//SW4-HL-Display-ImplementCECTCABC-00+}_20160126
+
+//SW4-HL-Display-SendCECTCABCBeforeInit-00+{_20161213
+extern int SendCEBeforeInit;
+extern int SendCTBeforeInit;
+extern int SendCABCBeforeInit;
+
+static int mdss_dsi_panel_ce_onoff_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long enable);
+static int mdss_dsi_panel_ct_set_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value);
+static int mdss_dsi_panel_cabc_set_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value);
+//SW4-HL-Display-SendCECTCABCBeforeInit-00+}_20161213
+
+static int DispOff = 0;	//SW4-HL-Display-NT35597-Fix_JGR-5432-AvoidCabcOffCmdIsSentDuring0x28And0x11Cmd-00+_20160601
+
+static int BistMode = 0;	//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+_20170809
+
 void mdss_dsi_panel_pwm_cfg(struct mdss_dsi_ctrl_pdata *ctrl)
 {
 	if (ctrl->pwm_pmi)
@@ -98,6 +186,13 @@ static void mdss_dsi_panel_bklt_pwm(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 	pr_debug("%s: ndx=%d level=%d duty=%d\n", __func__,
 					ctrl->ndx, level, duty);
 
+#if defined(CONFIG_PXLW_IRIS3)
+	if (iris_is_valid_cfg()) {
+		/*continuous splash should not setting dbc use dma*/
+		if (IRIS_CONT_SPLASH_LK != iris_get_cont_splash_type())
+			iris_dbc_bl_user_set(level);
+	}
+#endif
 	if (ctrl->pwm_period >= USEC_PER_SEC) {
 		ret = pwm_config_us(ctrl->pwm_bl, duty, ctrl->pwm_period);
 		if (ret) {
@@ -424,24 +638,190 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 					goto exit;
 				}
 			}
+			
+		//SW4-JasonSH-Display-BringUpFT8716U-00+{_20170619
+		switch (ctrl_pdata->panel_data.panel_info.panel_id)
+		{
+			//SW4-HL-Display-CTL-GT915L-CTC_n_AUO-BringUp-00+{_20180226
+			case FIH_CTL_CTC_OTM1911A_FHD_VIDEO_PANEL:
+                        case FIH_CTL_AUO_OTM1911A_FHD_VIDEO_PANEL:      //SW4-HL-CTL-HDR-ReadLcmSwId-00+_20180330
+                        case FIH_CTL_CTC_JD9522Z_FHD_VIDEO_PANEL:       //SW4-HL-CTL-HDR-ReadLcmSwId-00+_20180330
+				{
+                                        pr_debug("\n\n******************** [HL]%s, %d: FIH_CTL_CTC_OTM1911A_FHD_VIDEO_PANEL OR FIH_CTL_AUO_OTM1911A_FHD_VIDEO_PANEL OR FIH_CTL_CTC_JD9522Z_FHD_VIDEO_PANEL <-- START\n", __func__, __LINE__);
+					//*************************************************************					
+					//* HDR PX8418 reset sequence -- START
+					//*************************************************************
+					pr_debug("\n\n******************** [HL]%s, %d: HDR PX8418 reset sequence -- START\n", __func__, __LINE__);
+					rc = gpio_direction_output(ctrl_pdata->hdr_rst_gpio, 1);
+					if (rc) {
+						pr_err("%s: unable to set dir for rst gpio\n",
+							__func__);
+						goto exit;
+					}					
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) \
+					{
+						gpio_set_value((ctrl_pdata->hdr_rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+					}
+					pr_debug("\n\n******************** [HL]%s, %d: HDR PX8418 reset sequence -- END\n", __func__, __LINE__);
+					//*************************************************************					
+					//* HDR PX8418 reset sequence -- END
+					//*************************************************************
+					
+					if (pdata->panel_info.rst_seq_len) {
+						rc = gpio_direction_output(ctrl_pdata->rst_gpio,
+							pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+					}
+					
+					pr_debug("\n\n******************** [HL] %s, rst_seq_len = %d**********************\n\n", __func__, pdata->panel_info.rst_seq_len);
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) \
+					{
+						gpio_set_value((ctrl_pdata->rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+					}
+
+                                        pr_debug("\n\n******************** [HL]%s, %d: FIH_CTL_CTC_OTM1911A_FHD_VIDEO_PANEL OR FIH_CTL_AUO_OTM1911A_FHD_VIDEO_PANEL OR FIH_CTL_CTC_JD9522Z_FHD_VIDEO_PANEL <-- END\n", __func__, __LINE__);
+				}
+				break;
+			//SW4-HL-Display-CTL-GT915L-CTC_n_AUO-BringUp-00+}_20180226
+			case FIH_FT8716U_1080P_CTC_VIDEO_PANEL:
+				{
+					if (pdata->panel_info.rst_seq_len) {
+						rc = gpio_direction_output(ctrl_pdata->rst_gpio,
+							pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+						rc = gpio_direction_output(ctrl_pdata->tp_rst_gpio,pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+					}
+					pr_debug("\n\n******************** [JasonSH] %s, rst_seq_len = %d**********************\n\n", __func__, pdata->panel_info.rst_seq_len);
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
+						gpio_set_value((ctrl_pdata->rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+						gpio_set_value(ctrl_pdata->tp_rst_gpio,pdata->panel_info.rst_seq[i]);
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+						pr_debug("\n\n******************** [JasonSH] %s, i = %d , add tp reset**********************\n\n", __func__, i);
+					}
+				}
+				break;
+			//ZZDC sunqiupeng add for bringup PL2 2nd panel@20171226 start
+			case FIH_FT8719_1080P_VIDEO_PANEL:
+				{
+					if (pdata->panel_info.rst_seq_len) {
+						/*rc = gpio_direction_output(ctrl_pdata->tp_rst_gpio,pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+						gpio_set_value((ctrl_pdata->tp_rst_gpio), 1);
+						usleep_range(2 * 1000, 2 * 1000);*/
+
+						rc = gpio_direction_output(ctrl_pdata->rst_gpio,
+							pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+					}
+
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
+						gpio_set_value((ctrl_pdata->rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+					}
+				}
+				break;
+			case FIH_R69338_1080P_VIDEO_PANEL_PL2:
+				{
+					if (pdata->panel_info.rst_seq_len) {
+						rc = gpio_direction_output(ctrl_pdata->rst_gpio,
+							pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+						/*rc = gpio_direction_output(ctrl_pdata->tp_rst_gpio,pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}*/
+					}
+					pr_debug("\n\n******************** [JasonSH] %s, rst_seq_len = %d**********************\n\n", __func__, pdata->panel_info.rst_seq_len);
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
+						gpio_set_value((ctrl_pdata->rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+						//gpio_set_value(ctrl_pdata->tp_rst_gpio,pdata->panel_info.rst_seq[i]);
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+						pr_debug("\n\n******************** [JasonSH] %s, i = %d , add tp reset**********************\n\n", __func__, i);
+					}
+				}
+				break;
+				//ZZDC sunqiupeng add for bringup PL2 2nd panel@20171226 end
+			default:
+				{
+					if (pdata->panel_info.rst_seq_len) {
+						rc = gpio_direction_output(ctrl_pdata->rst_gpio,
+							pdata->panel_info.rst_seq[0]);
+						if (rc) {
+							pr_err("%s: unable to set dir for rst gpio\n",
+								__func__);
+							goto exit;
+						}
+					}
+					pr_debug("\n\n******************** [HL] %s, rst_seq_len = %d**********************\n\n", __func__, pdata->panel_info.rst_seq_len);
+					for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
+						gpio_set_value((ctrl_pdata->rst_gpio),
+							pdata->panel_info.rst_seq[i]);
+						if (pdata->panel_info.rst_seq[++i])
+							usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
+					}
+				}
+				break;
+		}
+		//SW4-JasonSH-Display-BringUpFT8716U-00+}_20170619
+	
+		pr_debug("\n\n******************** [HL] %s, for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) **********************\n\n", __func__);
+			if (gpio_is_valid(ctrl_pdata->bklt_en_gpio)) {
+
+				if (ctrl_pdata->bklt_en_gpio_invert)
+					rc = gpio_direction_output(
+						ctrl_pdata->bklt_en_gpio, 0);
+				else
+					rc = gpio_direction_output(
+						ctrl_pdata->bklt_en_gpio, 1);
 
-			if (pdata->panel_info.rst_seq_len) {
-				rc = gpio_direction_output(ctrl_pdata->rst_gpio,
-					pdata->panel_info.rst_seq[0]);
 				if (rc) {
-					pr_err("%s: unable to set dir for rst gpio\n",
+					pr_err("%s: unable to set dir for bklt gpio\n",
 						__func__);
 					goto exit;
 				}
 			}
 
-			for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
-				gpio_set_value((ctrl_pdata->rst_gpio),
-					pdata->panel_info.rst_seq[i]);
-				if (pdata->panel_info.rst_seq[++i])
-					usleep_range(pinfo->rst_seq[i] * 1000, pinfo->rst_seq[i] * 1000);
-			}
-
 			if (gpio_is_valid(ctrl_pdata->avdd_en_gpio)) {
 				if (ctrl_pdata->avdd_en_gpio_invert) {
 					rc = gpio_direction_output(
@@ -871,20 +1400,206 @@ static void mdss_dsi_panel_bl_ctrl(struct mdss_panel_data *pdata,
 	if (pdata->panel_disable_mode && (bl_level != 0))
 		return;
 
+	//SW4-HL-TP-EnableDisableIrqRightAfterOrBeforeLcmDisplayOnOrdisplayOff-00+{_20170515
+	pr_debug("\n\n*** [HL] %s: ctrl_pdata->panel_data.panel_info.panel_id = %d ***n\n", __func__, ctrl_pdata->panel_data.panel_info.panel_id);
+	switch (ctrl_pdata->panel_data.panel_info.panel_id)
+	{
+		//SW4-HL-Display-BringUpCTCOTM1911A-00+{_20180116
+		case FIH_CTC_OTM1911A_FHD_VIDEO_PANEL:
+		case FIH_AUO_OTM1911A_FHD_VIDEO_PANEL:	//SW4-HL-Display-OTM1911A-AUO-BringUp-00+_20180221
+                case FIH_CTC_JD9522Z_FHD_VIDEO_PANEL:           //SW4-HL-CTL-HDR-ReadLcmSwId-00+_20180330
+		case FIH_CTL_CTC_OTM1911A_FHD_VIDEO_PANEL:	//SW4-HL-Display-CTL-GT915L-CTC_n_AUO-BringUp-00+_20180226
+		case FIH_CTL_AUO_OTM1911A_FHD_VIDEO_PANEL:      //SW4-HL-CTL-HDR-ReadLcmSwId-00+_20180330
+		case FIH_CTL_CTC_JD9522Z_FHD_VIDEO_PANEL:       //SW4-HL-CTL-HDR-ReadLcmSwId-00+_20180330 
+			{
+                                pr_debug("\n\n*** [HL] %s: FIH_CTC_OTM1911A_FHD_VIDEO_PANEL OR FIH_AUO_OTM1911A_FHD_VIDEO_PANEL OR FIH_CTC_JD9522Z_FHD_VIDEO_PANEL ***\n\n", __func__);
+				if (bl_level == 0)
+				{
+					//Disable TP righ before backlight is turned off
+					//SW4-HL-TP-BringUpGT915L-00*{_20180119
+					pr_debug("\n\n*** [HL] %s, fih_goodix_ts_suspend() <-- START ***n\n", __func__);
+					fih_goodix_ts_suspend();
+					pr_debug("\n\n*** [HL] %s, fih_goodix_ts_suspend() <-- END ***n\n", __func__);
+					//SW4-HL-TP-BringUpGT915L-00*}_20180119
+
+					//TBD - FixRedScreenWhileShutdownBacklighLed
+					#if 0
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+{_20170614
+					//Send black pattern before power off backlihg LED to fix red screen issue
+					if (ctrl_pdata->bist_mode_black_pattern_cmds.cmd_cnt)
+					{
+						mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_black_pattern_cmds, CMD_REQ_COMMIT);
+						BistMode = 1;	//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+_20170809
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+}_20170614
+					#endif
+				}
+
+				if ((old_bl_level == 0) && (bl_level != 0))
+				{
+					//TBD - FixRedScreenWhileShutdownBacklighLed
+					#if 0
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+{_20170809
+					if (BistMode)
+					{
+						//Disable bist mode after backlight is turned off
+						if (ctrl_pdata->bist_mode_off_cmds.cmd_cnt)
+						{
+							mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_off_cmds, CMD_REQ_COMMIT);
+							BistMode = 0;
+						}
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+}_20170809
+					#endif
+
+					//TBD - FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled
+					#if 0
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+{_20170711
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- START ***\n\n", __func__);
+					fih_tp_lcm_resume_sensing_start();
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- END ***\n\n", __func__);
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+}_20170711
+					#endif
+				}
+			}
+			break;	
+		//SW4-HL-Display-BringUpCTCOTM1911A-00+}_20180116
+		case FIH_ILI7807E_1080P_VIDEO_PANEL:
+			{
+				pr_debug("\n\n*** [HL] %s: FIH_ILI7807E_1080P_VIDEO_PANEL ***\n\n", __func__);
+				if (bl_level == 0)
+				{
+					//SW4-HL-Display-GlanceMode-00+{_20170524
+					#if 0	//#ifdef CONFIG_AOD_FEATURE
+						/*If The the the system have been enter AOD and still panel off chnage panel to normal on mode then off*/
+						mdss_aod_resume_config(pdata);
+					#else
+					pr_debug("\n\n******************** [HL]%s: NOOOOOOOOOOOOOOOOOOO mdss_aod_resume_config(pdata)\n", __func__);
+					#endif
+					//SW4-HL-Display-GlanceMode-00+}_20170524
+
+					pr_debug("\n\n*** [HL] %s, fih_tp_lcm_suspend() <-- START ***n\n", __func__);
+					fih_tp_lcm_suspend();
+					pr_debug("\n\n*** [HL] %s, fih_tp_lcm_suspend() <-- END ***n\n", __func__);
+
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+{_20170614
+					//Send black pattern before power off backlihg LED to fix red screen issue
+					if (ctrl_pdata->bist_mode_black_pattern_cmds.cmd_cnt)
+					{
+						mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_black_pattern_cmds, CMD_REQ_COMMIT);
+						BistMode = 1;	//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+_20170809
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+}_20170614
+				}
+
+				if ((old_bl_level == 0) && (bl_level != 0))
+				{
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+{_20170809
+					if (BistMode)
+					{
+						//Disable bist mode after backlight is turned off
+						if (ctrl_pdata->bist_mode_off_cmds.cmd_cnt)
+						{
+							mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_off_cmds, CMD_REQ_COMMIT);
+							BistMode = 0;
+						}
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+}_20170809
+
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+{_20170711
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- START ***\n\n", __func__);
+					fih_tp_lcm_resume_sensing_start();
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- END ***\n\n", __func__);
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+}_20170711
+				}
+			}
+			break;
+		//SW4-HL-TP-B2N-NT36672-DoubleTap-00+{_20180302
+		case FIH_NT36672_FHD_CTC_B2N_VIDEO_PANEL:
+		case FIH_NT36672_H_GLASS_FHD_CTC_B2N_VIDEO_PANEL:
+			{
+				pr_debug("\n\n*** [HL] %s: FIH_NT36672_FHD_CTC_B2N_VIDEO_PANEL ***\n\n", __func__);
+				if (bl_level == 0)
+				{
+					//Disable TP right before backlight is turned off
+					pr_debug("\n\n*** [HL] %s, fih_nvt_ts_suspend() <-- START ***n\n", __func__);
+					fih_nvt_ts_suspend();
+					pr_debug("\n\n*** [HL] %s, fih_nvt_ts_suspend() <-- END ***n\n", __func__);
+
+					//TBD - FixRedScreenWhileShutdownBacklighLed
+					#if 0
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+{_20170614
+					//Send black pattern before power off backlihg LED to fix red screen issue
+					if (ctrl_pdata->bist_mode_black_pattern_cmds.cmd_cnt)
+					{
+						mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_black_pattern_cmds, CMD_REQ_COMMIT);
+						BistMode = 1;	//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+_20170809
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-00+}_20170614
+					#endif
+				}
+
+				if ((old_bl_level == 0) && (bl_level != 0))
+				{
+					//TBD - FixRedScreenWhileShutdownBacklighLed
+					#if 0
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+{_20170809
+					if (BistMode)
+					{
+						//Disable bist mode after backlight is turned off
+						if (ctrl_pdata->bist_mode_off_cmds.cmd_cnt)
+						{
+							mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->bist_mode_off_cmds, CMD_REQ_COMMIT);
+							BistMode = 0;
+						}
+					}
+					//SW4-HL-Display-FixRedScreenWhileShutdownBacklighLed-01+}_20170809
+					#endif
+
+					//TBD - FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled
+					#if 0
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+{_20170711
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- START ***\n\n", __func__);
+					fih_tp_lcm_resume_sensing_start();
+					pr_debug("\n\n*** [HL] %s: fih_tp_lcm_resume_sensing_start() <-- END ***\n\n", __func__);
+					//SW4-HL-Touch-FixTpNotWorkByQuickPressPowerKeyTwiceWhenDoubleTapEnabled-00+}_20170711
+					#endif
+				}
+			}
+
+			break;			
+		//SW4-HL-TP-B2N-NT36672-DoubleTap-00+}_20180302	
+		default:
+			break;
+	}
+	//SW4-HL-TP-EnableDisableIrqRightAfterOrBeforeLcmDisplayOnOrdisplayOff-00+}_20170515
+
 	if ((bl_level < pdata->panel_info.bl_min) && (bl_level != 0))
 		bl_level = pdata->panel_info.bl_min;
 
 	/* enable the backlight gpio if present */
 	mdss_dsi_bl_gpio_ctrl(pdata, bl_level);
 
+#if defined(CONFIG_PXLW_IRIS3)
+	psetting = iris_get_setting();
+	psetting->quality_cur.system_brightness = bl_level;
+	/* Don't set panel's brightness during HDR/SDR2HDR */
+	/* Set panel's brightness when sdr2hdr mode is 3 */
+	if (iris_is_valid_cfg() && psetting->quality_cur.pq_setting.sdr2hdr != SDR2HDR_Bypass && iris_get_sdr2hdr_mode() != 3)
+		return;
+#endif
+
 	switch (ctrl_pdata->bklt_ctrl) {
 	case BL_WLED:
+		pr_debug("\n\n******************** [HL] %s: BL_WLED	**********************\n\n",__func__);
 		led_trigger_event(bl_led_trigger, bl_level);
 		break;
 	case BL_PWM:
+		pr_debug("\n\n******************** [HL] %s: BL_PWM	**********************\n\n",__func__);
 		mdss_dsi_panel_bklt_pwm(ctrl_pdata, bl_level);
 		break;
 	case BL_DCS_CMD:
+		pr_debug("\n\n******************** [HL] %s: BL_DCS_CMD	**********************\n\n",__func__);
 		if (!mdss_dsi_sync_wait_enable(ctrl_pdata)) {
 			mdss_dsi_panel_bklt_dcs(ctrl_pdata, bl_level);
 			break;
@@ -1035,14 +2406,414 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 end:
 	pr_debug("%s:-\n", __func__);
 	return 0;
+
+//SW4-JasonSH-Display-EnhanceErrorHandling-00*_20170518
+cmds_fail:
+	BBOX_LCM_DISPLA_OFF_FAIL
+	return res;
+//SW4-JasonSH-Display-EnhanceErrorHandling-00*_20170518
+
+}
+
+//SW4-HL-Display-SendCECTCABCBeforeInit-00+{_20161213
+static int mdss_dsi_panel_ce_onoff_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long enable)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, enable = %ld ***\n\n", __func__,enable);
+
+	if (enable == 1)
+	{
+		len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ce_on_cmds_beforeInit, CMD_REQ_COMMIT);
+	}
+	else if (enable == 0)
+	{
+		len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ce_off_cmds_beforeInit, CMD_REQ_COMMIT);
+	}
+	else
+	{
+		pr_err("\n\n*** %s, Invlid input parameter ***\n\n", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+
+static int mdss_dsi_panel_ct_set_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, value = %ld ***\n\n", __func__,value);
+
+	switch (value)
+	{
+		case COLOR_TEMP_NORMAL:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_normal_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case COLOR_TEMP_WARM:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_warm_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case COLOR_TEMP_COLD:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_cold_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case BL_FILTER_DISABLE:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_normal_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case BL_FILTER_10:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_10_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case BL_FILTER_30:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_30_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case BL_FILTER_50:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_50_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		case BL_FILTER_75:
+			len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_75_cmds_beforeInit, CMD_REQ_COMMIT);
+			break;
+		default:
+			pr_err("%s: unhandled value=%ld\n", __func__, value);
+			return -EINVAL;
+			break;
+	}
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+
+static int mdss_dsi_panel_cabc_set_BeforeInit(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, value = %ld ***\n\n", __func__,value);
+
+	switch (value)
+	{
+		case CABC_OFF:
+			{
+				len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_off_cmds_beforeInit, CMD_REQ_COMMIT);
+			}
+			break;
+		case CABC_UI:
+			{
+				len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_ui_cmds_beforeInit, CMD_REQ_COMMIT);
+			}
+			break;
+		case CABC_STILL:
+			{
+				len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_still_cmds_beforeInit, CMD_REQ_COMMIT);
+			}
+			break;
+		case CABC_MOVING:
+			{
+				len = mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_moving_cmds_beforeInit, CMD_REQ_COMMIT);
+			}
+			break;
+		default:
+			pr_err("%s: unhandled value=%ld\n", __func__, value);
+			return -EINVAL;
+			break;
+	}
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+//SW4-HL-Display-SendCECTCABCBeforeInit-00+}_20161213
+
+//SW4-HL-Display-ImplementCECTCABC-00+}_20160126
+int mdss_dsi_panel_ce_onoff(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long enable)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, enable = %ld ***\n\n", __func__,enable);
+
+	if (!(ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT))
+	{
+		pr_err("%s, panel not init yet, not allow to set CE command!\n", __func__);
+		return -EBUSY;
+	}
+	else
+	{
+		pr_debug("\n\n*** [HL] %s, panel already init, allow to set CE command! ***\n\n", __func__);
+	}
+
+	if (enable == 1)
+	{
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ce_on_cmds, CMD_REQ_COMMIT);
+	}
+	else if (enable == 0)
+	{
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ce_off_cmds, CMD_REQ_COMMIT);
+	}
+	else
+	{
+		pr_debug("\n\n*** %s, Invlid input parameter ***\n\n", __func__);
+		return -EINVAL;
+	}
+
+	ce_status = enable;
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+
+int mdss_dsi_panel_ct_set(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, value = %ld ***\n\n", __func__,value);
+
+	if (!(ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT))
+	{
+		pr_err("%s, panel not init yet, not allow to set CT command!\n", __func__);
+		return -EBUSY;
+	}
+	else
+	{
+		pr_debug("\n\n*** [HL] %s, panel already init, allow to set CT command! ***\n\n", __func__);
+	}
+
+	switch (value) {
+	case COLOR_TEMP_NORMAL:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_normal_cmds, CMD_REQ_COMMIT);
+		break;
+	case COLOR_TEMP_WARM:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_warm_cmds, CMD_REQ_COMMIT);
+		break;
+	case COLOR_TEMP_COLD:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_cold_cmds, CMD_REQ_COMMIT);
+		break;
+	case BL_FILTER_DISABLE:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->ct_normal_cmds, CMD_REQ_COMMIT);
+		break;
+	case BL_FILTER_10:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_10_cmds, CMD_REQ_COMMIT);
+		break;
+	case BL_FILTER_30:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_30_cmds, CMD_REQ_COMMIT);
+		break;
+	case BL_FILTER_50:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_50_cmds, CMD_REQ_COMMIT);
+		break;
+	case BL_FILTER_75:
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->blf_75_cmds, CMD_REQ_COMMIT);
+		break;
+	default:
+		pr_debug("%s: unhandled value=%ld\n", __func__, value);
+		return -EINVAL;
+		break;
+	}
+
+	ct_status = value;
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+
+int mdss_dsi_panel_cabc_set(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, value = %ld ***\n\n", __func__,value);
+
+	if (!(ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT))
+	{
+		pr_err("%s, panel not init yet, not allow to set CABC command!\n", __func__);
+		return -EBUSY;
+	}
+	else
+	{
+		pr_debug("\n\n*** [HL] %s, panel already init, allow to set CABC command! ***\n\n", __func__);
+	}
+
+	//SW4-HL-Display-NT35597-Fix_JGR-5432-AvoidCabcOffCmdIsSentDuring0x28And0x11Cmd-00+{_20160601
+	if (DispOff) //SW4-JSH-Display-moveFeatureBeforeInitCommand
+	{
+		goto end;
+	}
+	//SW4-HL-Display-NT35597-Fix_JGR-5432-AvoidCabcOffCmdIsSentDuring0x28And0x11Cmd-00+}_20160601
+
+	switch (value)
+	{
+		case CABC_OFF:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_off_cmds, CMD_REQ_COMMIT);
+			break;
+		case CABC_UI:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_ui_cmds, CMD_REQ_COMMIT);
+			break;
+		case CABC_STILL:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_still_cmds, CMD_REQ_COMMIT);
+			break;
+		case CABC_MOVING:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->cabc_moving_cmds, CMD_REQ_COMMIT);
+			break;
+		default:
+			pr_debug("%s: unhandled value=%ld\n", __func__, value);
+			return -EINVAL;
+			break;
+	}
+
+end:	//SW4-HL-Display-NT35597-Fix_JGR-5432-AvoidCabcOffCmdIsSentDuring0x28And0x11Cmd-00+_20160601
+	cabc_status = value;
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+//SW4-HL-Display-ImplementCECTCABC-00+}_20160126
+
+// Start
+int mdss_dsi_panel_aie_set(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned long value)
+{
+	int len = 1;
+
+	pr_debug("\n\n*** [HL] %s, value = %ld ***\n\n", __func__, value);
+
+	if (!(ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT))
+	{
+		pr_err("%s, panel not init yet, not allow to set AIE command!\n", __func__);
+		return -EBUSY;
+	}
+	else
+	{
+		pr_debug("\n\n*** [HL] %s, panel already init, allow to set AIE command! ***\n\n", __func__);
+	}
+
+	switch (value)
+	{
+		case AIE_OFF:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->aie_off_cmds, CMD_REQ_COMMIT);
+			break;
+		case AIE_LOW:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->aie_low_cmds, CMD_REQ_COMMIT);
+			break;
+		case AIE_MID:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->aie_mid_cmds, CMD_REQ_COMMIT);
+			break;
+		case AIE_HIGH:
+			mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->aie_high_cmds, CMD_REQ_COMMIT);
+			break;
+		default:
+			pr_debug("%s: unhandled value=%ld\n", __func__, value);
+			return -EINVAL;
+			break;
+	}
+
+	aie_status = value;
+
+	pr_debug("\n\n******************** [HL] %s ---, len = %d **********************\n\n", __func__, len);
+
+	return len;
+}
+// End
+
+//SW4-HL-Display-DynamicReadWriteRegister-00+{_20160729
+static int tot_reg_val_len = 0;
+static char res_reg_val[2];
+void mdss_dsi_panel_read_reg_get(char *reg_val)
+{
+	pr_debug("\n\n******************** [HL]%s: <-- START\n", __func__);
+
+	if (tot_reg_val_len < 2)
+	{
+		sprintf(reg_val, "0x%x\n", res_reg_val[0]);
+	}
+	else
+	{
+		sprintf(reg_val, "0x%x,0x%x\n", res_reg_val[0], res_reg_val[1]);
+	}
+
+	pr_debug("\n\n******************** [HL] %s ---, reg_val = (%s) **********************\n\n", __func__, reg_val);
+
+	return;
 }
 
+static char read_reg[2] = {0x0A, 0x00};
+void mdss_dsi_panel_read_reg_set(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned int reg, unsigned int reg_len)
+{
+	char *rx_buf;
+	int i = 0;
+
+	pr_err("\n\n*** [HL] %s, reg = 0x%x, reg_len = %d ***\n\n", __func__, reg, reg_len);
+
+	res_reg_val[0] = 0;
+	res_reg_val[1] = 0;
+	pr_err("%s, Clear the array which keeps the return value of lcm driver ic to 0x00!\n", __func__);
+
+	rx_buf = kzalloc(PANEL_REG_ADDR_LEN, GFP_KERNEL);
+	read_reg[0] = reg;
+	mdss_dsi_panel_cmd_read(ctrl_pdata, read_reg[0], read_reg[1],
+					NULL, rx_buf, reg_len);
+
+	pr_err("%s: (reg, value) = (0x%x, 0x%x)\n", __func__, reg, rx_buf[0]);
+
+	//memcpy(res_reg_val, rx_buf, sizeof(res_reg_val));
+	for (i = 0; i < reg_len; i++)
+	{
+		res_reg_val[i] = rx_buf[i];
+	}
+	tot_reg_val_len = reg_len;
+
+	pr_debug("\n\n******************** [HL] %s: res_reg_val = (0x%x) **********************\n\n", __func__, res_reg_val[0]);
+
+	kfree(rx_buf);
+
+	pr_debug("\n\n******************** [HL] %s --- **********************\n\n", __func__);
+
+	return;
+}
+
+void mdss_dsi_panel_write_reg_set(struct mdss_dsi_ctrl_pdata *ctrl_pdata, unsigned int len, char *data)
+{
+	char *delim = ",";
+	char *token;
+	int i = 0;
+	long input = 0;
+
+	pr_err("\n\n*** [HL] %s, len = %d, data = (%s) ***\n\n", __func__, len, data);
+
+	if (ctrl_pdata->write_reg_cmds.cmd_cnt)
+	{
+		//Dcs command length
+		ctrl_pdata->write_reg_cmds.blen = len;
+
+		//Dcs command register and data
+		for(token = strsep(&data, delim); token != NULL; token = strsep(&data, delim))
+		{
+			pr_debug("\n\n******************** [HL] %s: data = %s **********************\n\n", __func__, token);
+			if (strict_strtol(token, 16, &input))
+			{
+				return;
+			}
+			ctrl_pdata->write_reg_cmds.cmds->payload[i] = input;
+
+			i++;
+		}
+
+		//Send Dcs command
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->write_reg_cmds, CMD_REQ_COMMIT);
+	}
+
+	pr_debug("\n\n******************** [HL] %s ---**********************\n\n", __func__);
+
+	return;
+}
+//SW4-HL-Display-DynamicReadWriteRegister-00+}_20160729
+
 static int mdss_dsi_panel_low_power_config(struct mdss_panel_data *pdata,
 	int enable)
 {
 	struct mdss_dsi_ctrl_pdata *ctrl = NULL;
 	struct mdss_panel_info *pinfo;
 
+	pr_debug("\n\n******************** [HL]%s: <-- START\n", __func__);
+
 	if (pdata == NULL) {
 		pr_err("%s: Invalid input data\n", __func__);
 		return -EINVAL;
@@ -2393,16 +4229,24 @@ int mdss_panel_parse_bl_settings(struct device_node *np,
 	int rc = 0;
 	u32 tmp;
 
+	pr_debug("\n\n******************** [HL] %s <-- START  **********************\n\n", __func__);
+
 	ctrl_pdata->bklt_ctrl = UNKNOWN_CTRL;
 	data = of_get_property(np, "qcom,mdss-dsi-bl-pmic-control-type", NULL);
+	pr_debug("\n\n******************** [HL] %s: data = (%s)  **********************\n\n", __func__, data);
 	if (data) {
 		if (!strcmp(data, "bl_ctrl_wled")) {
+			pr_debug("\n\n******************** [HL] %s: bl_ctrl_wled  **********************\n\n", __func__);
 			led_trigger_register_simple("bkl-trigger",
 				&bl_led_trigger);
 			pr_debug("%s: SUCCESS-> WLED TRIGGER register\n",
 				__func__);
 			ctrl_pdata->bklt_ctrl = BL_WLED;
+#if defined(CONFIG_PXLW_IRIS3)
+			iris_set_bklt_ctrl(bl_led_trigger);
+#endif
 		} else if (!strcmp(data, "bl_ctrl_pwm")) {
+			pr_debug("\n\n******************** [HL] %s: bl_ctrl_pwm	**********************\n\n", __func__);
 			ctrl_pdata->bklt_ctrl = BL_PWM;
 			ctrl_pdata->pwm_pmi = of_property_read_bool(np,
 					"qcom,mdss-dsi-bl-pwm-pmi");
@@ -2500,6 +4357,10 @@ void mdss_dsi_unregister_bl_settings(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
 {
 	if (ctrl_pdata->bklt_ctrl == BL_WLED)
 		led_trigger_unregister_simple(bl_led_trigger);
+#if defined(CONFIG_PXLW_IRIS3)
+	if (ctrl_pdata->bklt_ctrl == BL_WLED)
+		iris_set_bklt_ctrl(NULL);
+#endif
 }
 
 static int mdss_dsi_panel_timing_from_dt(struct device_node *np,
